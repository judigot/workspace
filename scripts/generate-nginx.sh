#!/usr/bin/env bash
set -euo pipefail

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
ROOT_DIR=$(cd "${SCRIPT_DIR}/.." && pwd)

DOMAIN=${DOMAIN:-"judigot.com"}
WWW_DOMAIN=${WWW_DOMAIN:-"www.${DOMAIN}"}
OPENCODE_SUBDOMAIN=${OPENCODE_SUBDOMAIN:-"opencode.${DOMAIN}"}
WORKSPACE_SUBDOMAIN=${WORKSPACE_SUBDOMAIN:-"workspace.${DOMAIN}"}

SSL_CERT=${SSL_CERT:-"/etc/letsencrypt/live/${DOMAIN}/fullchain.pem"}
SSL_KEY=${SSL_KEY:-"/etc/letsencrypt/live/${DOMAIN}/privkey.pem"}

OPENCODE_BACKEND=${OPENCODE_BACKEND:-"127.0.0.1:4097"}
OPENCODE_SERVER_USERNAME=${OPENCODE_SERVER_USERNAME:-""}
OPENCODE_SERVER_PASSWORD=${OPENCODE_SERVER_PASSWORD:-""}
DEFAULT_APP=${DEFAULT_APP:-""}

# Base64-encode credentials for nginx to forward to OpenCode iframe endpoint
if [ -n "$OPENCODE_SERVER_USERNAME" ] && [ -n "$OPENCODE_SERVER_PASSWORD" ]; then
  OPENCODE_AUTH_BASIC=$(printf '%s:%s' "$OPENCODE_SERVER_USERNAME" "$OPENCODE_SERVER_PASSWORD" | base64)
else
  OPENCODE_AUTH_BASIC=""
fi

WORKSPACE_ROOT=${WORKSPACE_ROOT:-"/var/www/workspace"}
DASHBOARD_PORT=${DASHBOARD_PORT:-3200}
DASHBOARD_API_PORT=${DASHBOARD_API_PORT:-3100}
WIDGET_DIR=${WIDGET_DIR:-"/var/www/static"}

# Backward compatibility: if VITE_APPS is set but APPS is not, convert to new format
if [ -z "${APPS:-}" ] && [ -n "${VITE_APPS:-}" ]; then
  APPS=""
  for entry in $VITE_APPS; do
    slug=${entry%%:*}
    port=${entry##*:}
    APPS="${APPS:+${APPS} }${slug}:frontend:${port}"
  done
fi
APPS=${APPS:-""}

OUTPUT=${1:-"${ROOT_DIR}/dist/nginx.conf"}
OUTPUT_DIR=$(dirname "$OUTPUT")

mkdir -p "$OUTPUT_DIR"

normalize_slug() {
  local slug="$1"
  slug="${slug#/}"
  slug="${slug%/}"
  echo "$slug"
}

slug_to_upstream_name() {
  local slug="$1"
  slug=$(normalize_slug "$slug")
  slug="${slug//-/_}"
  echo "$slug"
}

# Parse a colon-separated app spec into variables
# Format: slug:type:frontend_port[:backend_port[:options]]
parse_app() {
  local spec="$1"
  APP_SLUG=""
  APP_TYPE=""
  APP_FRONTEND_PORT=""
  APP_BACKEND_PORT=""
  APP_OPTIONS=""

  IFS=':' read -r APP_SLUG APP_TYPE APP_FRONTEND_PORT APP_BACKEND_PORT APP_OPTIONS <<< "$spec"
  APP_SLUG=$(normalize_slug "$APP_SLUG")
}

has_option() {
  local options="$1"
  local opt="$2"
  IFS=',' read -ra opts <<< "$options"
  for o in "${opts[@]}"; do
    if [ "$o" = "$opt" ]; then
      return 0
    fi
  done
  return 1
}

# --- Generate config ---

cat > "$OUTPUT" <<EOF
# Nginx configuration generated by generate-nginx.sh

map \$http_upgrade \$connection_upgrade {
    default upgrade;
    ''      close;
}
EOF

# Generate upstream blocks for each app
for app in $APPS; do
  parse_app "$app"
  upstream_name=$(slug_to_upstream_name "$APP_SLUG")

  case "$APP_TYPE" in
    frontend)
      cat >> "$OUTPUT" <<EOF

upstream app_${upstream_name}_frontend {
    server 127.0.0.1:${APP_FRONTEND_PORT};
    keepalive 32;
}
EOF
      ;;
    fullstack)
      cat >> "$OUTPUT" <<EOF

upstream app_${upstream_name}_frontend {
    server 127.0.0.1:${APP_FRONTEND_PORT};
    keepalive 32;
}

upstream app_${upstream_name}_backend {
    server 127.0.0.1:${APP_BACKEND_PORT};
    keepalive 32;
}
EOF
      ;;
    laravel)
      cat >> "$OUTPUT" <<EOF

upstream app_${upstream_name}_backend {
    server 127.0.0.1:${APP_FRONTEND_PORT};
    keepalive 32;
}
EOF
      ;;
  esac
done

cat >> "$OUTPUT" <<EOF

upstream opencode_backend {
    server ${OPENCODE_BACKEND};
    keepalive 8;
}

upstream dashboard_backend {
    server 127.0.0.1:${DASHBOARD_PORT};
    keepalive 8;
}

upstream dashboard_api {
    server 127.0.0.1:${DASHBOARD_API_PORT};
    keepalive 8;
}

server {
    listen 80 default_server;
    listen [::]:80 default_server;
    server_name ${DOMAIN} ${WWW_DOMAIN};

    location /.well-known/acme-challenge/ {
        root /var/www/html;
    }

    location / {
        return 301 https://\$host\$request_uri;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${DOMAIN} ${WWW_DOMAIN};

    ssl_certificate ${SSL_CERT};
    ssl_certificate_key ${SSL_KEY};

    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-ECDSA-AES128-GCM-SHA256:ECDHE-RSA-AES128-GCM-SHA256:ECDHE-ECDSA-AES256-GCM-SHA384:ECDHE-RSA-AES256-GCM-SHA384:ECDHE-ECDSA-CHACHA20-POLY1305:ECDHE-RSA-CHACHA20-POLY1305:DHE-RSA-AES128-GCM-SHA256:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    ssl_session_cache shared:SSL:10m;
    ssl_session_timeout 1d;
    ssl_session_tickets off;

    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    gzip on;
    gzip_vary on;
    gzip_proxied any;
    gzip_comp_level 6;
    gzip_min_length 1000;
    gzip_types text/plain text/css text/xml application/json application/javascript application/rss+xml application/atom+xml image/svg+xml;

    client_max_body_size 50M;

    proxy_connect_timeout 60s;
    proxy_send_timeout 300s;
    proxy_read_timeout 300s;

    # Serve the DevBubble widget JS as a static file
    location = /dev-bubble.js {
        alias ${WIDGET_DIR}/dev-bubble.js;
        add_header Cache-Control "public, max-age=300";
        add_header Content-Type "application/javascript";
        add_header X-Content-Type-Options "nosniff" always;
    }
EOF

# sub_filter snippet injected into each app's main location block
WIDGET_SCRIPT_TAG="<script src=\"https://${DOMAIN}/dev-bubble.js\" data-opencode-url=\"https://${OPENCODE_SUBDOMAIN}\" data-dashboard-url=\"https://${DOMAIN}\"></script>"

# Generate location blocks for each app
for app in $APPS; do
  parse_app "$app"
  upstream_name=$(slug_to_upstream_name "$APP_SLUG")

  case "$APP_TYPE" in
    frontend)
      cat >> "$OUTPUT" <<EOF

    location /${APP_SLUG}/__vite_hmr {
        proxy_pass http://app_${upstream_name}_frontend/${APP_SLUG}/__vite_hmr;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        proxy_buffering off;
    }

    location /${APP_SLUG}/ {
        proxy_pass http://app_${upstream_name}_frontend/${APP_SLUG}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Host \$host;
        add_header X-Content-Type-Options "nosniff" always;
        add_header X-XSS-Protection "1; mode=block" always;
        add_header Referrer-Policy "strict-origin-when-cross-origin" always;
        proxy_buffering off;

        # Inject DevBubble widget into HTML responses
        proxy_set_header Accept-Encoding "";
        sub_filter '</body>' '${WIDGET_SCRIPT_TAG}</body>';
        sub_filter_once on;
    }
EOF
      ;;
    fullstack)
      # Vite HMR websocket
      cat >> "$OUTPUT" <<EOF

    location /${APP_SLUG}/__vite_hmr {
        proxy_pass http://app_${upstream_name}_frontend/${APP_SLUG}/__vite_hmr;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400s;
        proxy_send_timeout 86400s;
        proxy_buffering off;
    }
EOF

      # Optional websocket route
      if has_option "${APP_OPTIONS:-}" "ws"; then
        cat >> "$OUTPUT" <<EOF

    location /${APP_SLUG}/ws {
        proxy_pass http://app_${upstream_name}_backend/ws;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400s;
        proxy_buffering off;
    }
EOF
      fi

      # API proxy
      cat >> "$OUTPUT" <<EOF

    location /${APP_SLUG}/api/ {
        proxy_pass http://app_${upstream_name}_backend/api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_buffering on;
        proxy_buffer_size 128k;
        proxy_buffers 4 256k;
    }

    location /${APP_SLUG}/ {
        proxy_pass http://app_${upstream_name}_frontend/${APP_SLUG}/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_buffering off;

        # Inject DevBubble widget into HTML responses
        proxy_set_header Accept-Encoding "";
        sub_filter '</body>' '${WIDGET_SCRIPT_TAG}</body>';
        sub_filter_once on;
    }
EOF
      ;;
    laravel)
      cat >> "$OUTPUT" <<EOF

    location /${APP_SLUG}/ {
        proxy_pass http://app_${upstream_name}_backend/;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_set_header X-Forwarded-Port \$server_port;
        proxy_set_header X-Forwarded-Host \$host;
        proxy_buffering off;

        # Inject DevBubble widget into HTML responses
        proxy_set_header Accept-Encoding "";
        sub_filter '</body>' '${WIDGET_SCRIPT_TAG}</body>';
        sub_filter_once on;
    }
EOF
      ;;
  esac
done

cat >> "$OUTPUT" <<EOF

    location /api/ {
        proxy_pass http://dashboard_api/api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    location / {
        proxy_pass http://dashboard_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400s;
        proxy_buffering off;
    }

    location = /.env {
        deny all;
        return 404;
    }

    location ~ ^/\.git {
        deny all;
        return 404;
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${OPENCODE_SUBDOMAIN};

    ssl_certificate ${SSL_CERT};
    ssl_certificate_key ${SSL_KEY};

    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;
    add_header Content-Security-Policy "frame-ancestors https://${DOMAIN} https://${WORKSPACE_SUBDOMAIN}" always;

    location / {
        proxy_pass http://opencode_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400s;
        proxy_buffering off;
        proxy_hide_header X-Frame-Options;
        proxy_hide_header WWW-Authenticate;
EOF

  if [ -n "$OPENCODE_AUTH_BASIC" ]; then
    cat >> "$OUTPUT" <<EOF
        proxy_set_header Authorization "Basic ${OPENCODE_AUTH_BASIC}";
EOF
  fi

  cat >> "$OUTPUT" <<EOF
    }
}

server {
    listen 443 ssl http2;
    listen [::]:443 ssl http2;
    server_name ${WORKSPACE_SUBDOMAIN};

    ssl_certificate ${SSL_CERT};
    ssl_certificate_key ${SSL_KEY};

    add_header X-Content-Type-Options "nosniff" always;
    add_header Referrer-Policy "strict-origin-when-cross-origin" always;

    location /api/ {
        proxy_pass http://dashboard_api/api/;
        proxy_http_version 1.1;
        proxy_set_header Connection "";
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
    }

    location / {
        proxy_pass http://dashboard_backend;
        proxy_http_version 1.1;
        proxy_set_header Upgrade \$http_upgrade;
        proxy_set_header Connection \$connection_upgrade;
        proxy_set_header Host \$host;
        proxy_set_header X-Real-IP \$remote_addr;
        proxy_set_header X-Forwarded-For \$proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto \$scheme;
        proxy_read_timeout 86400s;
        proxy_buffering off;
    }
}
EOF

echo "Wrote nginx config to ${OUTPUT}"
